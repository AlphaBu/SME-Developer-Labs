#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <iostream>
#include <vector>
#include <chrono>
#include "logger.h"
#include "cmdlineparser.h" 

#include "xclbin_helper.h" 
#include "opencv2/opencv.hpp"

#include "blur.h" 

using namespace sda;
using namespace sda::utils;

static void IplImage2Raw(IplImage* img, uchar* y, int stride_y, uchar* u, int stride_u, uchar* v, int stride_v);
static void Raw2IplImage(uchar* y, int stride_y, uchar* u, int stride_u, uchar* v, int stride_v, IplImage* img);


// -------------------------------------------------------------------------------------------
// An event callback function that prints the operations performed by the OpenCL runtime.
// -------------------------------------------------------------------------------------------
void event_cb(cl_event event, cl_int cmd_status, void *id) 
{
  std::cout << "  kernel finished processing request " << *(int *)id << std::endl;
}

// -------------------------------------------------------------------------------------------
// Struct returned by BlurDispatcher() and used to keep track of the request sent to the kernel
// The sync() method waits for completion of the request. After it returns, results are ready
// -------------------------------------------------------------------------------------------
struct BlurRequest {

  cl_event mEvent[3];	
  int      mId;

  BlurRequest(int id) {
    mId = id;
  }	

  void sync()
  {
  	// Wait until the outputs have been read back
	clWaitForEvents(1, &mEvent[2]);
	clReleaseEvent(mEvent[0]);
   	clReleaseEvent(mEvent[1]);
   	clReleaseEvent(mEvent[2]);	
  }

};


// -------------------------------------------------------------------------------------------
// Class used to dispatch requests to the kernel
// The BlurDispatcher() method schedules the necessary operations (write, kernel, read) and
// returns a BlurRequest* struct which can be used to track the completion of the request. 
// The dispatcher has its own OOO command queue allowing multiple requests to be scheduled
// and executed independently by the OpenCL runtime.
// -------------------------------------------------------------------------------------------
class BlurDispatcher {

public:

  BlurDispatcher(
  	cl_device_id     &Device,
    cl_context       &Context,
  	cl_program       &Program )	
  {
	mKernel  = clCreateKernel(Program, "BlurKernel", &mErr);
	mQueue   = clCreateCommandQueue(Context, Device, CL_QUEUE_PROFILING_ENABLE | CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE, &mErr);
	mContext = Context;
	mCounter = 0;
  }
  
  BlurRequest* operator() (
	unsigned char    *src,
	unsigned int      width,
	unsigned int      height,
	unsigned int      stride,
	unsigned char    *dst ) 
  { 
  
  	BlurRequest* req = new BlurRequest(mCounter++);

	unsigned nbytes = (stride*height);

	// Create input buffer (host to device)
	mSrcExt.flags = XCL_MEM_DDR_BANK0;
	mSrcExt.param = 0;
	mSrcExt.obj   = src;
  	mSrcBuf[0] = clCreateBuffer(mContext, CL_MEM_EXT_PTR_XILINX | CL_MEM_USE_HOST_PTR | CL_MEM_READ_ONLY,  nbytes, &mSrcExt, &mErr);
	
	// Create output buffer (device to host)
	mDstExt.flags = XCL_MEM_DDR_BANK0;
	mDstExt.param = 0;
	mDstExt.obj   = dst;
	mDstBuf[0] = clCreateBuffer(mContext, CL_MEM_EXT_PTR_XILINX | CL_MEM_USE_HOST_PTR | CL_MEM_WRITE_ONLY, nbytes, &mDstExt, &mErr);
  
	// Schedule the writing of the inputs
	clEnqueueMigrateMemObjects(mQueue, 1, mSrcBuf, 0, 0, nullptr,  &req->mEvent[0]);	

  	// Set the kernel arguments
  	clSetKernelArg(mKernel, 0, sizeof(cl_mem),       &mSrcBuf[0]);
  	clSetKernelArg(mKernel, 1, sizeof(unsigned int), &width);
  	clSetKernelArg(mKernel, 2, sizeof(unsigned int), &height);
  	clSetKernelArg(mKernel, 3, sizeof(unsigned int), &stride);
  	clSetKernelArg(mKernel, 4, sizeof(cl_mem),       &mDstBuf[0]);

	// Schedule the execution of the kernel
	clEnqueueTask(mQueue, mKernel, 1,  &req->mEvent[0], &req->mEvent[1]);	
	
	// Schedule the reading of the outputs
  	clEnqueueMigrateMemObjects(mQueue, 1, mDstBuf, CL_MIGRATE_MEM_OBJECT_HOST, 1, &req->mEvent[1], &req->mEvent[2]);

	// Register call back to notify of kernel completion
	// clSetEventCallback(req->mEvent[1], CL_COMPLETE, event_cb, &req->mId); 
	
	return req;
  }; 
 
  ~BlurDispatcher()
  {  
	clReleaseCommandQueue(mQueue);
	clReleaseKernel(mKernel);
  };  
  
private:
  cl_kernel         mKernel;
  cl_command_queue  mQueue;	
  cl_context        mContext;  
  cl_mem_ext_ptr_t  mSrcExt;
  cl_mem_ext_ptr_t  mDstExt;
  cl_int            mErr;
  cl_mem            mSrcBuf[1];
  cl_mem            mDstBuf[1]; 
  int               mCounter; 
};



int main(int argc, char** argv)
{
	std::cout << std::endl;	
	std::cout << "Xilinx 2D Filter Example Application\n";
		
	// ---------------------------------------------------------------------------------
	// Parse command line
	// ---------------------------------------------------------------------------------

	CmdLineParser parser;
	parser.addSwitch("--nruns", "-n", "Number of times to image is processed", "1");
	parser.addSwitch("--fpga", "-x", "FPGA binary (xclbin) file to use", "xclbin/fpga.hw.xilinx_aws-vu9p-f1_4ddr-xpr-2pr_4_0.awsxclbin");
	parser.addSwitch("--input", "-i", "Input image file");

	//parse all command line options
	parser.parse(argc, argv);
	string inputImage = parser.value("input");
	string fpgaBinary = parser.value("fpga");
	int    numRuns    = parser.value_to_int("nruns");

	if (inputImage.size() == 0) {
		std::cout << std::endl;	
		std::cout << "ERROR: input image file must be specified using -i command line switch" << std::endl;
		exit(1);
	}
	
	std::cout << std::endl;	
	std::cout << "FPGA binary    : " << fpgaBinary << std::endl;
	std::cout << "Input image    : " << inputImage << std::endl;
	std::cout << "Number of runs : " << numRuns    << std::endl;
	std::cout << std::endl;	
	
	
	// ---------------------------------------------------------------------------------
	// Load XCLBIN file, create OpenCL context, device and program
	// ---------------------------------------------------------------------------------

	std::cout << "Programming FPGA" << std::endl;
	cl_context    	context;
	cl_program    	program;
	cl_device_id	device;
	load_xclbin_file(fpgaBinary.c_str(), context, device, program);



	// ---------------------------------------------------------------------------------
	// Read input image and format inputs
	// ---------------------------------------------------------------------------------
	
	// Create filenames for input and ouput images
	std::string srcFileName  = inputImage;
	std::string dstFileName  = inputImage.substr(0, inputImage.size()-4)+"_out.bmp";

	// Read Input image
	IplImage *src, *dst;
	src = cvLoadImage(srcFileName.c_str()); //format is BGR
	if(!src) {
		std::cout << "ERROR: Loading image " << srcFileName << " failed" << std::endl;
		exit(1);
	}
	unsigned width  = src->width;
	unsigned height = src->height;
	unsigned stride = width;
	unsigned nbytes = (stride*height);

	// 4k alligned buffers for efficient data transfer to the kernel
	std::vector<uchar, aligned_allocator<uchar>> y_src(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> u_src(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> v_src(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> y_dst(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> u_dst(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> v_dst(nbytes);

	// Create destination image
	dst = cvCreateImage(cvSize(width, height), src->depth, src->nChannels);

	// Convert CV Image to AXI video data
	IplImage2Raw(src, y_src.data(), stride, u_src.data(), stride, v_src.data(), stride);


	// ---------------------------------------------------------------------------------
	// Make requests to kernel(s) 
	// ---------------------------------------------------------------------------------
	// Note: change the number of kernels in the device, or reorder the sync() methods
	// to see the impact on performance and how requests are scheduled.
	// ---------------------------------------------------------------------------------

	std::cout << std::endl;	
	std::cout << "Running FPGA version" << std::endl;	

	// Create a dispatcher of requests to the Blur kernel(s) 
	BlurDispatcher Blur(device, context, program);

  auto fpga_begin = std::chrono::high_resolution_clock::now();

	BlurRequest* request[numRuns*3];
  for(int xx=0; xx<numRuns; xx++) 
  {
	// Make independent requests to Blur Y, U and V planes
	// Requests will run sequentially if there is a single kernel
	// Requests will run in parallel is there are two or more kernels
	request[xx*3+0] = Blur(y_src.data(), width, height, stride, y_dst.data());
	request[xx*3+1] = Blur(u_src.data(), width, height, stride, u_dst.data());
	request[xx*3+2] = Blur(v_src.data(), width, height, stride, v_dst.data());
	//std::cout << "Blurring requests #1 for Y, U, V planes scheduled" << std::endl;

	// Wait for completion of the outstanding requests
	//request[0]->sync();
	//request[1]->sync();
	//request[2]->sync();
   	//std::cout << "Blurring requests #1 for Y, U, V planes completed" << std::endl;
  }
  for(int xx=0; xx<numRuns; xx++) 
  {
	// Wait for completion of the outstanding requests
	request[xx*3+0]->sync();
	request[xx*3+1]->sync();
	request[xx*3+2]->sync();
  }


  auto fpga_end = std::chrono::high_resolution_clock::now();

	// ---------------------------------------------------------------------------------
	// Format output and write image out 
	// ---------------------------------------------------------------------------------

    	// Convert processed image back to CV Image
    	Raw2IplImage(y_dst.data(), stride, u_dst.data(), stride, v_dst.data(), stride, dst);

	// Convert image to cvMat and write it to disk
    	cvConvert( dst, cvCreateMat(height, width, CV_32FC3 ) );
	cvSaveImage(dstFileName.c_str(), dst);

	// Release allocated memory
	cvReleaseImage(&src);
	cvReleaseImage(&dst);

	// ---------------------------------------------------------------------------------
	// Compute reference results and compare 
	// ---------------------------------------------------------------------------------

	std::cout << std::endl;
   	std::cout << "Running Software version" << std::endl;

	// Create output buffers for reference results
	std::vector<uchar, aligned_allocator<uchar>> y_ref(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> u_ref(nbytes);
	std::vector<uchar, aligned_allocator<uchar>> v_ref(nbytes);

  auto cpu_begin = std::chrono::high_resolution_clock::now();

  #pragma omp parallel for
  for(int xx=0; xx<numRuns; xx++) 
  {
	// Compute reference results
	BlurPixels(y_src.data(), width, height, stride, y_ref.data());
	BlurPixels(u_src.data(), width, height, stride, u_ref.data());
	BlurPixels(v_src.data(), width, height, stride, v_ref.data());
  }

  auto cpu_end = std::chrono::high_resolution_clock::now();

	// Compare results
	bool diff = false;
	for (int y = 0; y < height; y++) {
        	for (int x = 0; x < width; x++) {
			if ( y_dst[y*stride+x] != y_ref[y*stride+x] ) diff = true;
			if ( u_dst[y*stride+x] != u_ref[y*stride+x] ) diff = true;
			if ( v_dst[y*stride+x] != v_ref[y*stride+x] ) diff = true;
        	}
    	}

	std::cout << std::endl;	
	std::cout << "*******************************************************" << std::endl;	
	if(diff) {
		std::cout << "MATCH FAILED: Output has mismatches with reference" << std::endl;
	} else {
		std::cout << "MATCH PASS: Output matches reference" << std::endl;
	}
	std::cout << "*******************************************************" << std::endl;	


	std::chrono::duration<double> fpga_duration = fpga_end - fpga_begin;
	std::cout << "FPGA Time:       " << fpga_duration.count() << " s" << std::endl;
	std::cout << "FPGA Throughput: " 
	          << (double) numRuns*3*nbytes / fpga_duration.count() / (1024.0*1024.0)
	          << " MB/s" << std::endl;

	std::chrono::duration<double> cpu_duration = cpu_end - cpu_begin;
	std::cout << "CPU Time:        " << cpu_duration.count() << " s" << std::endl;
	std::cout << "CPU Throughput:  " 
	          << (double) numRuns*3*nbytes / cpu_duration.count() / (1024.0*1024.0)
	          << " MB/s" << std::endl;

	// ---------------------------------------------------------------------------------
	// Clean-up and Exit 
	// ---------------------------------------------------------------------------------

	clReleaseProgram(program);
	clReleaseContext(context);	
	clReleaseDevice(device);

	return (diff?1:0);
}


static void IplImage2Raw(IplImage* img, uchar* y_buf, int stride_y, uchar* u_buf, int stride_u, uchar* v_buf, int stride_v)
{
    // Assumes RGB or YUV 4:4:4
    for (int y = 0; y < img->height; y++)
    {
        for (int x = 0; x < img->width; x++)
        {
        	CvScalar cv_pix = cvGet2D(img, y, x);
		y_buf[y*stride_y+x] = (uchar)cv_pix.val[0];
		u_buf[y*stride_u+x] = (uchar)cv_pix.val[1];
		v_buf[y*stride_v+x] = (uchar)cv_pix.val[2];
        }
    }
}

static void Raw2IplImage(uchar* y_buf, int stride_y, uchar* u_buf, int stride_u, uchar* v_buf, int stride_v, IplImage* img )
{
    // Assumes RGB or YUV 4:4:4
    for (int y = 0; y < img->height; y++)
    {
        for (int x = 0; x < img->width; x++)
        {
        	CvScalar cv_pix;
		cv_pix.val[0] = y_buf[y*stride_y+x];
		cv_pix.val[1] = u_buf[y*stride_u+x];
		cv_pix.val[2] = v_buf[y*stride_v+x];
		cvSet2D(img, y, x, cv_pix);
        }
    }
}

